#include <iostream>
#include <math.h>
#include "mVector.h"

//Problem 123 (COMPLETE)
//Let p_n be the nth prime: 2, 3, 5, 7, 11, ..., and let r be the remainder when (p_n−1)^n + (p_n+1)^n is divided by p_n^2.
//For example, when n = 3, p_3 = 5, and 43 + 63 = 280 ≡ 5 mod 25.
//The least value of n for which the remainder first exceeds 10^9 is 7037.
//Find the least value of n for which the remainder first exceeds 1010.

//NOTES
//o Know remainder is 2 for n even and 2*n*p_n for n odd (Problem 120).

//Generate Primes (Sieve of Sundaram)
MVector GeneratePrimes(int MaxNumber){
	int k = (MaxNumber-2) / 2;
	MVector IntegerList(k);
	MVector PrimesList(1);
	
	//Generate vector of 1 to MaxNumber
	for(int i = 0; i < k; i++){
		IntegerList[i] = i+1;
	}
	
	//Apply Sundaram conditions
	for(int i=1; i<=k; i++){
		for(int j=i; j <= (k-i)/(2*i+1); j++){
			IntegerList[i + j + 2*i*j - 1] = 0;
		}
	}
	
	//Save rescaled integers to PrimeList
	int IndexCounter = 1;
	
	for(int i = 1; i < k+1; i++){
		if(IntegerList[i-1] != 0){
			PrimesList.append(2 * IntegerList[i-1] + 1);
			IndexCounter++;
		}
	}
	
	//Append 2 to start of PrimesList (Not generated by Sundaram Algorithm)
	PrimesList[0] = 2;
	
	return PrimesList;
}


void PrimeSquareRemainder(long long maxVal){
	MVector PrimesList;
	long long r = 0;
	int n = 1;
	
	//Generate primes upto 10 mil
	PrimesList = GeneratePrimes(10000000);
	
	//While the remainder is less than the values required, increase by 2 and use the remainder formula from problem 120 (see notes)
	while(r < maxVal){
		n+=2;
		r = 2 * PrimesList[n-1] * n;
	}
	
	//Output result
	std::cout << "The least value of n for which the remainder first exceeds " << maxVal << " is " << n << "\n";
}


int main() {
	
	//change the value of the variable maxVal to change the limit of the remainder exceeding point
	long long maxVal = 10000000000;

	PrimeSquareRemainder(maxVal);
	
	
	
}
